PRACTICAL 3

PART A
Program to solve alpha-beta pruning.
MAX, MIN=1000, -1000
def minimax(depth, nodeIndex, maximizingPlayer, values, alpha, beta):
if depth==3:
return values[nodeIndex]
if maximizingPlayer:
best=MIN
for i in range(0, 2):
val=minimax(depth+1, nodeIndex*2+i, False, values, alpha, beta)
best=max(best, val)
alpha=max(alpha, best)
if beta<=alpha:
break
return best
else:
best=MAX
for i in range(0, 2):
val=minimax(depth+1, nodeIndex*2+i, True, values, alpha, beta)
best=min(best, val)
beta=min(beta, best)
if beta<=alpha:
break
return best
if __name__=="__main__":
values=[3, 5, 6, 9, 1, 2, 0, -1]
print("The optimal value is : ", minimax(0, 0, True, values, MIN, MAX))

PART B
import math
increment=0.1
startingPoint=[1, 1]
point1=[1, 5]
point2=[6, 4]
point3=[5, 2]
point4=[2, 1]
def distance(x1, y1, x2, y2):
dist=math.pow(x2-x1, 2)+math.pow(y2-y1, 2)
return dist
def sumofdistance(x1, y1, px1, py1, px2, py2, px3, py3, px4, py4):
d1=distance(x1, y1, px1, py1)
d2=distance(x1, y1, px2, py2)
d3=distance(x1, y1, px3, py3)
d4=distance(x1, y1, px4, py4)
return d1+d2+d3+d4
def newdistance(x1, y1, point1, point2, point3, point4):
d1=[x1, y1]
d1temp=sumofdistance(x1, y1, point1[0], point1[1], point2[0], point2[1],
point3[0], point3[1], point4[0], point4[1])
d1.append(d1temp)
return d1
mindistance=sumofdistance(startingPoint[0], startingPoint[1], point1[0],
point1[1], point2[0], point2[1], point3[0], point3[1], point4[0], point4[1])
flag=True
def newPoints(minimum, d1, d2, d3, d4):
if d1[2]==minimum:
return [d1[0], d1[1]]
elif d2[2]==minimum:
return [d2[0], d2[1]]
elif d3[2]==minimum:
return [d3[0], d3[1]]
elif d4[2]==minimum:
return [d4[0], d4[1]]
i=1
while flag:
d1=newdistance(startingPoint[0]+increment, startingPoint[1], point1,
point2, point3, point4)
d2=newdistance(startingPoint[0]-increment, startingPoint[1], point1,
point2, point3, point4)
d3=newdistance(startingPoint[0], startingPoint[1]+increment, point1,
point2, point3, point4)
d4=newdistance(startingPoint[0], startingPoint[1]-increment, point1,
point2, point3, point4)
print(i,'',round(startingPoint[0],2),round(startingPoint[1],2))
minimum=min(d1[2], d2[2], d3[2], d4[2])
if minimum<mindistance:
startingPoint=newPoints(minimum, d1, d2, d3, d4)
mindistance=minimum
i=i+1
else:
flag=False
