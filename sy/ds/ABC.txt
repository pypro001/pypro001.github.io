
<Code>
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                                        LINEAR ALGEBRA

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

practical 1

Write a program which demonstrates the following:  
 1]Addition of two complex numbers
 2]Displaying the conjugate of a complex number
 3]Plotting a set of complex numbers
 4]Creating a new plot by rotating the given number by a degree 90, 180, 270 degrees and also by scaling by a number a = 1/2, a = 1/3, a = 2 etc.



program1]

#Addition of two complex numbers

print("Format for writing complex number: a+bj.\n")
c1=complex(input("Enter First Complex Number:"))
c2=complex(input("Enter second Complex Number:"))
print("Sum of both the Complex number is", c1 + c2)

program2]

#Displaying the conjugate of a complex number

import numpy as np
in_complx1 = 2+4j
out_complx1 = np.conj(in_complx1)
print ("Output conjugated complex number of  2+4j : ", out_complx1)

program3]

#Plotting a set of complex numbers
# import library
import matplotlib.pyplot as plt  
# create data of complex numbers
data = [1+2j, -1+4j, 4+3j, -4, 2-1j, 3+9j, -2+6j, 5]  
# extract real part
x = [ele.real for ele in data]
# extract imaginary part
y = [ele.imag for ele in data]  
# plot the complex numbers
plt.scatter(x, y)
plt.ylabel('Imaginary')
plt.xlabel('Real')
plt.show()

program4]

#Creating a new plot by rotating the given number by a degree 90, 180, 270 degrees and also by scaling by a number a = 1/2, a = 1/3, a = 2 etc.

import matplotlib.pyplot as plt
x = 2 + 2j
z = 1j
n=int(input("Enter the angle of graph:"))
if n==90:
    plt.scatter(x.real , x.imag, color='r')
    c = x*z
    plt.title("90 degree")
    plt.scatter(c.real, c.imag)
    plt.show()
if n==180:
    plt.scatter(x.real,x.imag, color = 'r')
    plt.title("180 degree")
    plt.scatter(-1*x.real, -1*x.imag, color='b')
    plt.show()
if n==270:
    plt.title("270 degree")
    plt.scatter(x.real, x.imag, color='r')
    c=x*z
    plt.scatter(c.real, c.imag)
plt.show()


PRACTICAL NO. 2


Write a program to do the following:  
  1]Enter a vector u as a n-list
  2]Enter another vector v as a n-list
  3]Find the vector au + bv for different values of a and b
  4]Find the dot product of u and v


1]


#n-list
#Enter a vector u as a n-list

u = list()
n = int(input("Enter number of elements in vector1:"))
print('Enter numbers in vector1:')
for i in range(int(n)):
    ul = int(input("u:"))
    u.append(int(ul))
print('vector u: ',u)

#Enter another vector v as a n-list
v = list()
m = int(input("Enter number of elements in vector2:"))
print('Enter numbers in vector2:')
for i in range(int(m)):
    vl=int(input("v:"))
    v.append(int(vl))
print('vector v: ',v)
   
 
2]

  Find the vector au + bv for different values of a and b
  Find the dot product of u and v

# scalar multiplication of vectors and dot product of vectors
import numpy as np
# enter vector as n-list
x = np.array ([5,6,7])
y = np.array ([1,2,3])
print(x)
print(y)
print("enter value of a and b")
a = int (input())
b = int(input())
c = a*x+ b*y
d = np. dot (x,y)
print('au+bv vector is', c)
print('dot product is' , d)


PRACTICAL NO. 3


Basic Matrix Operations:  
  1]Matrix Addition, Subtraction, Multiplication
  2]Check if matrix is invertible.
  3]If yes then find Inverse.

1]

Matrix Addition, Subtraction, Multiplication
#matrix operation

import numpy

# Matrix 1
A=[ [1, 2, 3], [3, 4, 5], [6, 7, 8] ]

# Matrix 2
B=[ [5, 6, 7], [1, 2, 3], [5, 3, 8] ]

print(("Addition of matrix = "))
print(numpy.add(A,B))
print(("Subtraction of matrix = "))
print(numpy.subtract(A,B))
print(("Multiplication of matrix = "))
print(numpy.matmul(A,B))

2]

#Check if matrix is invertible.  If yes then find Inverse.


import numpy as  np
M = ([[1,2,1],[2,1,0],[3,0,2]])
print("the matrix M is:",M)
a = np.linalg.det(M)
print("Determinant of matrix M is", a)
if a !=0:
    Minv = np.linalg.inv(M)
    print("The inverse of matrix M is:", Minv)
else:
    print("matrix is not invertible")



PRACTICAL NO.4


Write a program to convert a matrix into its row echelon form. (Order 2). Write a program to find rank of a matrix

	
# Write a program to convert a matrix into its row echelon form
def echolon(size):
    for row in range(0, size):
        for col in range(0, size):
            if (row >= col):
                print("0", end=" ")
            else:
                print("n", end=" ")
        print()
size = 5
echolon(size)


#Program to find rank of a matrix 

# Python 3 program to find rank of a matrix
class rankMatrix(object):
    def __init__(self, Matrix):
        self.R = len(Matrix)
        self.C = len(Matrix[0])
         
    # Function for exchanging two rows of a matrix
    def swap(self, Matrix, row1, row2, col):
        for i in range(col):
            temp = Matrix[row1][i]
            Matrix[row1][i] = Matrix[row2][i]
            Matrix[row2][i] = temp
             
    # Function to Display a matrix
    def Display(self, Matrix, row, col):
        for i in range(row):
            for j in range(col):
                print (" " + str(Matrix[i][j]))
            print ('\n')
             
    # Find rank of a matrix
    def rankOfMatrix(self, Matrix):
        rank = self.C
        for row in range(0, rank, 1):
             
            # Before we visit current row
            # 'row', we make sure that
            # mat[row][0],....mat[row][row-1]
            # are 0.
     
            # Diagonal element is not zero
            if Matrix[row][row] != 0:
                for col in range(0, self.R, 1):
                    if col != row:
                         
                        # This makes all entries of current
                        # column as 0 except entry 'mat[row][row]'
                        multiplier = (Matrix[col][row] /
                                      Matrix[row][row])
                        for i in range(rank):
                            Matrix[col][i] -= (multiplier *
                                               Matrix[row][i])
                                                 
            # Diagonal element is already zero.
            # Two cases arise:
            # 1) If there is a row below it
            # with non-zero entry, then swap
            # this row with that row and process
            # that row
            # 2) If all elements in current
            # column below mat[r][row] are 0,
            # then remove this column by
            # swapping it with last column and
            # reducing number of columns by 1.
            else:
                reduce = True
                 
                # Find the non-zero element
                # in current column
                for i in range(row + 1, self.R, 1):
                     
                    # Swap the row with non-zero
                    # element with this row.
                    if Matrix[i][row] != 0:
                        self.swap(Matrix, row, i, rank)
                        reduce = False
                        break
                         
                # If we did not find any row with
                # non-zero element in current
                # column, then all values in
                # this column are 0.
                if reduce:
                     
                    # Reduce number of columns
                    rank -= 1
                     
                    # copy the last column here
                    for i in range(0, self.R, 1):
                        Matrix[i][row] = Matrix[i][rank]
                         
                # process this row again
                row -= 1
                 
        # self.Display(Matrix, self.R,self.C)
        return (rank)
 
# Driver Code
if __name__ == '__main__':
    Matrix = [[10, 20, 10],
              [-20, -30, 10],
              [30, 50, 0]]
    RankMatrix = rankMatrix(Matrix)
    print ("Rank of the Matrix is:",
           (RankMatrix.rankOfMatrix(Matrix)))



PRACTICAL NO. 5
Write a program to do the following: 
  1]Enter a vector b and find the projection of b orthogonal to a given vector u.
  2]Find the projection of b orthogonal to a set of given vectors.


1]

Enter a vector b and find the projection of b orthogonal to a given vector u.

# Vector projection
import numpy as np
u=np.array([1,2,3])
v=np.array([4,5,6])
v_norm=np.sqrt(sum(v**2))     
# norm=<v,v>=v1.v1+v2.v2+v3.v3
projection_u_on_v=(np.dot(u,v)/v_norm**2)*v    # projec v=(<u,v>/<v,v>)*v
print("the projection of vector u on v : ",projection_u_on_v)


2]

#Find the projection of b orthogonal to a set of given vectors.

import numpy as np
v1=np.array([1,1,1,1])
v2=np.array([1,2,4,5])
v3=np.array([1,-3,-4,-2])
v1_norm=np.sqrt(sum(v1**2))
v2_norm=np.sqrt(sum(v2**2))
w1=v1
w2=v2-((np.dot(v2,w1)/v1_norm**2))*w1   # w2 is basis of v2
w3=v3-((np.dot(v3,w2)/v2_norm**2))*w2   # w3 is basis of v3
print(w1)
print(w2)
print(w3)


PRACTICAL NO. 6

#Write a program to calculate eigenvalue and eigenvector (Order 2 and 3)


import numpy as np
A=np.mat("-2 1;12 -3")
print ("A \n",A)
print ("eigen values of A are", np.linalg.eigvals (A)) 
eigenvalues, eigenvectors=np.linalg.eig (A) 
print("first set of eigen values", eigenvalues) 
print ("eigen vectors are", eigenvectors)



------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


                                                                      DATA STRUCTURES


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#LINKED LIST
class Node():
    def __init__(self,data):
        self.data = data
        self.next = None
class linkedlist():
    def __init__(self):
        self.head = None
        self.tail = None
        self.size = 0
    def prepending(self,data):
        newnode = Node(data)
        if self.head == None:
            self.head = newnode
            self.tail = newnode
        else:
            newnode.next = self.head
            self.head = newnode
        print("newnode inserted at the head position.")
        self.size+=1
    def insertfromtail(self,data):
        newnode = Node(data)
        if self.tail == None:
            self.head = newnode
            self.tail = newnode
        else:
            self.tail.next = newnode
            self.tail = newnode
        print("newnode inserted at the tail position.")
        self.size += 1
    def deletefromhead(self):
        if self.head == None:
            print("linked list empty")
        else:
            value = self.head.data
            print("delete node is ", value)
            self.head = self.head.next
            self.size -= 1
    def deletefromtail(self):
        if self.head == None:
            print("linked list empty")
        else:
            current = self.head
            while(current.next!=None):
                prev = current
                current = current.next
            value = current.data
            prev.next=None
            print("deleted node is ",value)
            self.tail = prev
            self.size -= 1
    def traversaloflist(self):
        current = self.head
        while(current!=None):
            print(current.data)
            current = current.next
        print("end")
    def search(self , value):
       
        current = self.head
        while(current!=None):
            if current.data!=value:
                current = current.next   
            return True
        return False  
    def deletevalue(self,value):
        current = self.head
        while(current!=None and current.data!=value):
            prev =current
            current = current.next
        if current == None:
            print("node not found")
        else:
            self.size -= 1
            if current == self.head:
                self.head = current.next
            elif current==self.tail:
                prev.next = current.next
                self.tail=prev
            else:
                prev.next=current.next
            print("value deleted successfully")
x = linkedlist()
choice = 0
print("menu")
print("1. Prepend.\n2. insert from tail.\n3. delete from head.\n4. delete from tail.\n5. search for a value.\n6. delete a value.\n7. display.\n8. exit.")
choice = int(input("enter your choice : "))
while(choice!=8):
    if choice==1:
        value = int(input("enter the value to be inserted : "))
        x.prepending(value)
    if choice==2:
        value = int(input("enter the value to be inserted : "))
        x.insertfromtail(value)
    if choice==3:
        x.deletefromhead()
    if choice==4:
        x.deletefromtail()
    if choice==5:
        value = int(input("enter the value to be searched : "))
        result = x.search(value)
        if result==True:
            print("Value found at node in the linked list")
        else:
            print("value not found")
    if choice == 6:
        value = int(input("enter the value to be deleted : "))
        x.deletevalue(value)
    if choice == 7:
        x.traversaloflist()
    choice = int(input("enter your choice again : "))


--------------------------------------------------------------------------------------------------


#DOUBLY LINKED LIST
class node():
    def __init__(self,data):
        self.data=data
        self.next=None
        self.prev=None

class doublylinkedlist():
    def __init__(self):
        self.head=None
        self.tail=None
        self.size=0

    def insertfromhead(self,data):
        newnode=node(data)
        if self.head==None:
            self.head=newnode
            self.tail=newnode
        else:
            newnode.next=self.head
            self.head.prev=newnode
            self.head=newnode
        print("newnode inserted at the head position")
        self.size+=1
        
    def insertfromtail(self,data):
            newnode=node(data)
            if self.tail==None:
               self.head=newnode
               self.tail=newnode
            else:
                self.tail.next=newnode
                newnode.prev=self.tail
                self.tail=newnode
            print("newnode inserted at the tail position")
            self.size+=1
            
    def deletefromhead(self):
            if self.head==None:
                print("linked list empty")
            else:
                value=self.head.data
                print("deleted node is",value)
                self.head=self.head.next
                self.head.prev=None
                self.size-=1
                
    def deletefromtail(self):
            if self.head==None:
                print("linked list empty")
            else:
                current=self.head
                while(current.next!=None):
                    prevnode=current
                    current=current.next
                value=current.data
                prevnode.next=None
                print("deleted node is",value)
                self.tail=prevnode
                self.size-=1
                
    def traversaloflist(self):
            current=self.head
            while current!=None:
                print(current.data)
                current=current.next
            print("end")
    def search(self,value):
            self.n=0
            current=self.head
            while(current!=None):
                self.n+=1
                if currentdata!=value:
                    current=current.next
                else:
                    return true
                return false
    def deletevalue(self,value):
            current=self.head
            while(current!=None&current.data!=value):
                prevnode=current
                current=current.next
            if current==None:
                print("node not found")
            else:
                self.size-=1
                if current==self.head:
                    self.head=current.next
                elif current==self.tail:
                    prevnode.next=current.next
                    self.tail=prev
                else:
                    prevnode.next=current.next
            print("value deleted successfully")
x=doublylinkedlist()
print("menu")
print("1.Insert from head\n2.insert from tail\n3.delete from head\n4.delet from tail")
print("5.search for a value\n6.delete a value\n7.display a linked list\n8.exit")
choice=int(input("please enter your choice"))
while(choice!=8):
    if choice==1:
        value=int(input("enter the value to be inserted"))
        x.insertfromhead(value)
    if choice==2:
        value=int(input("enter the value to be inserted"))
        x.insertfromtail(value)
    if choice==3:
        x.deletefromhead()
    if choice==4:
        x.deletefromtail()
    if choice==5:
        value=int(input("enter the value to be searched"))
        result=x.search(value)
        if result==true:
            print("value found at node",x.n,"in the linked list")
        else:
            print("value not found")
    if choice==6:
        value=int(input("enter the value to be deleted"))
        x.deletevalue(value)
    if choice==7:
        x.traversaloflist()
    choice=int(input("enter your choice again"))

===================================================================================================================
#PROGRAM TO IMPLEMENT STACK
class Node():
    def __init__(self,d):
        self.data = d
        self.next = None
class StackLL():
    def __init__(self):
        self.top = None
        self.size = 0
    def isEmpty(self):
        if (self.size==0):
            return True
        else:
            return False
    def push(self,value):
        n = Node(value)
        n.next = self.top
        self.top = n
        self.size += 1
    def peek(self):
        if (self.isEmpty()):
            print('stack is empty')
        else:
            print('The topmost element in stack is : ', self.top.data)
    def pop(self):
        if (self.isEmpty()):
            print('stack is empty')
        else:
            value = self.top.data
            self.top = self.top.next
            self.size -= 1
            print('The poped value is : ',value)   
    def display(self):
        if (self.isEmpty()):
            print('stack is empty')
        else:
            self.temp = self.top
            while(self.temp != None):
                print(self.temp.data)
                self.temp = self.temp.next
    def length(self):
        if (self.isEmpty()):
            print('stack is empty')
        else:
            print('The length of stack is : ', self.size)
st = StackLL()
print('Menu')
print('1.Push\n2.Pop\n3.Peek\n4.Display\n5.Length\n6.exit')
choice = int(input('Press Your Choice : '))
while choice<=5:
    if choice == 1:
        value = int(input('Enter the value to be inserted in the stack : '))
        st.push(value)
    elif choice == 2:
        st.pop()
    elif (choice==3):
        st.peek()
    elif (choice==4):
        st.display()
    elif (choice==5):
        st.length()
    choice = int(input('Please enter your Choice : '))

===============================================================================================================
#PROGRAM TO IMPLEMENT QUEUE
class Node():
    def __init__(self,data):
        self.data = data
        self.next = None
class Queue_Stracture():
    def __init__(self):
        self.head = None
        self.last = None
    def enqueue_operation(self,data):
        if self.last==None:
            self.head = Node(data)
            self.last = self.head
        else:
            self.last.next = Node(data)
            self.last = self.last.next
    def dequeue_operation(self):
        if self.head==None:
            return None
        else:
            val_returned = self.head.data
            self.head = self.head.next
            return val_returned
my_instance = Queue_Stracture()
while True:
    print('enqueue <value>')
    print('dequeue')
    print('quit')
    my_input = input('What operaton would you like to perform ?').split()
    operation = my_input[0].strip().lower()
    if operation == 'enqueue':
        my_instance.enqueue_operation(int(my_input[1]))
    elif operation == 'dequeue':
        dequeue = my_instance.dequeue_operation()
        if dequeue==None:
            print('The queue is empty')
        else:
            print('The deleted element is : ',int(dequeue))
    elif operation == 'quit':
        break
    else:
        print('Wrong input or Operation')
        break


=============================================================================================================
#PROGRAM TO IMPLEMENT PRIORITY QUEUE
# A simple implementation of Priority Queue
# using Queue.
class PriorityQueue(object):
	def __init__(self):
		self.queue = []

	def __str__(self):
		return ' '.join([str(i) for i in self.queue])

	# for checking if the queue is empty
	def isEmpty(self):
		return len(self.queue) == 0

	# for inserting an element in the queue
	def insert(self, data):
		self.queue.append(data)

	# for popping an element based on Priority
	def delete(self):
		try:
			max_val = 0
			for i in range(len(self.queue)):
				if self.queue[i] > self.queue[max_val]:
					max_val = i
			item = self.queue[max_val]
			del self.queue[max_val]
			return item
		except IndexError:
			print()
			exit()

if __name__ == '__main__':
	myQueue = PriorityQueue()
	myQueue.insert(12)
	myQueue.insert(1)
	myQueue.insert(14)
	myQueue.insert(7)
	print(myQueue)		
	while not myQueue.isEmpty():
		print(myQueue.delete())


==============================================================================================================

#WRITE A PROGRAM TO IMPLEMENT BINARY TREE WITH INSERTION, DELETION, TRAVERSAL OPERATIONS
class Node:
   # Constructor to create a new node
    def __init__(self, key):
        self.key = key
        self.left = None
        self.right = None  
# A utility function to do inorder traversal of BST
def inorder(root):
    if root is not None:
        inorder(root.left)
        print (root.key,end=" ")
        inorder(root.right) 
def insert(node, key): 
    # If the tree is empty, return a new node
    if node is None:
        return Node(key)
    # Otherwise recur down the tree
    if key < node.key:
        node.left = insert(node.left, key)
    else:
        node.right = insert(node.right, key)
    # return the (unchanged) node pointer
    return node
  
def minValueNode(node):
    current = node
    # loop down to find the leftmost leaf
    while(current.left is not None):
        current = current.left
    return current  
def deleteNode(root, key):
    # Base Case
    if root is None:
        return root
    if key < root.key:
        root.left = deleteNode(root.left, key)
    elif(key > root.key):
        root.right = deleteNode(root.right, key)
    else:
        # Node with only one child or no child
        if root.left is None:
            temp = root.right
            root = None
            return temp
        elif root.right is None:
            temp = root.left
            root = None
            return temp
        temp = minValueNode(root.right)
        root.key = temp.key
        root.right = deleteNode(root.right, temp.key)
    return root
# Driver code
""" Let us create following BST
              50
           /     \
          30      70
         /  \    /  \
       20   40  60   80 """
  
root = None
root = insert(root, 50)
root = insert(root, 30)
root = insert(root, 20)
root = insert(root, 40)
root = insert(root, 70)
root = insert(root, 60)
root = insert(root, 80)  
print ("Inorder traversal of the given tree")
inorder(root)  
print ("\nDelete 20")
root = deleteNode(root, 20)
print ("Inorder traversal of the modified tree")
inorder(root)
print ("\nDelete 30")
root = deleteNode(root, 30)
print ("Inorder traversal of the modified tree")
inorder(root)  
print ("\nDelete 50")
root = deleteNode(root, 50)
print ("Inorder traversal of the modified tree")
inorder(root)


========================================================================================================

#PROGRAM TO IMPLEMENT HUFFMAN CODING
string = 'BCAADDDCCACACAC'
# Creating tree nodes
class NodeTree(object):
    def __init__(self, left=None, right=None):
        self.left = left
        self.right = right
    def children(self):
        return (self.left, self.right)
    def nodes(self):
        return (self.left, self.right)
    def __str__(self):
        return '%s_%s' % (self.left, self.right)
# Main function implementing huffman coding
def huffman_code_tree(node, left=True, binString=''):
    if type(node) is str:
        return {node: binString}
    (l, r) = node.children()
    d = dict()
    d.update(huffman_code_tree(l, True, binString + '0'))
    d.update(huffman_code_tree(r, False, binString + '1'))
    return d
# Calculating frequency
freq = {}
for c in string:
    if c in freq:
        freq[c] += 1
    else:
        freq[c] = 1
freq = sorted(freq.items(), key=lambda x: x[1], reverse=True)
nodes = freq
while len(nodes) > 1:
    (key1, c1) = nodes[-1]
    (key2, c2) = nodes[-2]
    nodes = nodes[:-2]
    node = NodeTree(key1, key2)
    nodes.append((node, c1 + c2))
    nodes = sorted(nodes, key=lambda x: x[1], reverse=True)
huffmanCode = huffman_code_tree(nodes[0][0])
print(' Char | Huffman code ')
print('----------------------')
for (char, frequency) in freq:
    print(' %-4r |%12s' % (char, huffmanCode[char]))

=====================================================================================
#PRGRAM TO IMPLEMENT GRAPH
#This class represents a directed graph using adjacency list representation
from collections import defaultdict
class Graph:
    def __init__(self,vertices):
        self.V= vertices #No. of vertices
        self.Graph = defaultdict(list) # default dictionary to store graph
 # function to add an edge to graph
    def addEdge(self,u,v):
        self.Graph[u].append(v)
 # Use BFS to check path between s and d
    def isReachable(self, s, d):
  # Mark all the vertices as not visited
        visited =[False]*(self.V)
  # Create a queue for BFS
        queue=[]
  # Mark the source node as visited and enqueue it
        queue.append(s)
        visited[s] = True
        while queue:
   #Dequeue a vertex from queue
            n = queue.pop(0)  
   # If this adjacent node is the destination node,
   # then return true
            if n == d:
                return True
   # Else, continue to do BFS
            for i in self.Graph[n]:
                if visited[i] == False:
                    queue.append(i)
                    visited[i] = True
  # If BFS is complete without visited d
                return False
# Create a graph given in the above diagram
g =Graph(4)
g.addEdge(0, 1)
g.addEdge(0, 2)
g.addEdge(1, 2)
g.addEdge(2, 0)
g.addEdge(2, 3)
g.addEdge(3, 3)
u =1; v = 3
if g.isReachable(u, v):
    print("There is a path from %d to %d" % (u,v))
else :
    print("There is no path from %d to %d" % (u,v))
u = 3; v = 1
if g.isReachable(u, v) :
    print("There is a path from %d to %d" % (u,v))
else :
    print("There is no path from %d to %d" % (u,v))

==============================================================================================
#TRAVELLING SALESMAN PROGRAM

from sys import maxsize
from itertools import permutations
V=4
def travellingSalesmanProblem(graph,s):
    vertex=[]
    for i in range(V):
        if i!=s:
            vertex.append(i)
    min_path=maxsize
    next_permutation=permutations(vertex)
    for i in next_permutation:
        current_pathweight=0
        k=s
        for j in i:
            current_pathweight += graph[k][j]
            k=j
        current_pathweight+=graph[k][s]
        min_path=min(min_path,current_pathweight)
    return min_path
if __name__=="__main__":
    graph=[[0,10,15,20],[10,0,35,25],[15,35,0,30],[20,25,30,0]]
    s=0
    print(travellingSalesmanProblem(graph,s))

==========================================================================================================
#CREATING BASIC HASH TABLE FOR INSERTION , DELETION , TRAVERSAL OPERATIONS
def display_hash(hashTable):	
	for i in range(len(hashTable)):
		print(i, end = " ")		
		for j in hashTable[i]:
			print("-->", end = " ")
			print(j, end = " ")			
		print()
HashTable = [[] for _ in range(10)]
def Hashing(keyvalue):
	return keyvalue % len(HashTable)
def insert(Hashtable, keyvalue, value):	
	hash_key = Hashing(keyvalue)
	Hashtable[hash_key].append(value)
insert(HashTable, 10, 'Allahabad')
insert(HashTable, 25, 'Mumbai')
insert(HashTable, 20, 'Mathura')
insert(HashTable, 9, 'Delhi')
insert(HashTable, 21, 'Punjab')
insert(HashTable, 21, 'Noida')
display_hash (HashTable)


==========================================================================================================
#HASH TABLE TO HANDLE COLLISIONS USING OVERFLOW CHAINING
def printArray(arr, n):
	
	# Iterating and printing the array
	for i in range(n):
		print(arr[i], end = " ")
def hashing(table, tsize, arr, N):	
	# Iterating through the array
	for i in range(N):	
		# Computing the hash value
		hv = arr[i] % tsize
		if (table[hv] == -1):
			table[hv] = arr[i]		
		else:
			for j in range(tsize):				
				t = (hv + j * j) % tsize			
				if (table[t] == -1):				
					table[t] = arr[i]
					break
	printArray(table, N)
# Driver code
arr = [ 50, 700, 76,
		85, 92, 73, 101 ]
N = 7
L = 7
hash_table = [0] * 7
for i in range(L):
	hash_table[i] = -1
hashing(hash_table, L, arr, N)
</code>
