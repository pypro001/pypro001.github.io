PRACTICAL 8

PART A
Program to solve block of world problem
import copy
class node:
def __init__(self, state):
self.state=state
self.children=[]
def action(self):
for i in range(3):
for j in range(3):
if i!=j:
if self.state[i]:
temp=copy.deepcopy(self.state)
m=temp[i].pop()
temp[j].append(m)
if temp not in self.children:
self.children.append(node(temp))
def search(self, goal, queue):
print("Called")
if self.state==goal:
print("Inspection state : ", self.state)
return True
for child in self.children:
if child.state not in queue:
print(child.state)
child.action()
print(child.children[0].state)
temp=copy.deepcopy(child.state)
queue.append(temp)
result=child.search(goal, queue)
if result:
return result
return self.search(goal, queue)
print("Queue full error")
return False
i_state=[['a'], ['b', 'c'], []]
root=node(i_state)
root.action()
goal=[[], ['a', 'b', 'c'], []]
queue=[]
root.search(goal, queue)


PART B
adjacent(1,2).	
adjacent(2,1).
adjacent(1,3).	
adjacent(3,1).
adjacent(1,4).	
adjacent(4,1).
adjacent(1,5).	
adjacent(5,1).
adjacent(2,3).	
adjacent(3,2).
adjacent(2,4).	
adjacent(4,2).
adjacent(3,4).	
adjacent(4,3).
adjacent(4,5).	
adjacent(5,4).

color(1,red,a).	color(1,red,b).
color(2,blue,a).	color(2,blue,b).  
color(3,green,a).	color(3,green,b).
color(4,yellow,a).	color(4,blue,b).
color(5,blue,a).	color(5,green,b).

conflict(Coloring):-
	adjacent(X,Y),
	color(X,Color,Coloring),
	color(Y,Color,Coloring).

conflict(R1,R2,Coloring):-
	adjacent(R1,R2),
	color(R1,Color,Coloring),
	color(R2,Color,Coloring).